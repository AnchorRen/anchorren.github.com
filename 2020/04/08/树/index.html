<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="算法,树,二叉树,满二叉树,完全二叉树,二叉搜索树,红黑树,堆,堆排序,">










<meta name="description" content="基本概念高度这个概念，其实就是从下往上度量，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是 0。 深度这个概念在生活中是从地面往下度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 0。 层数跟楼层类似，起点是 1，也就是说根节点的位于第 1 层。   满二叉树 叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，">
<meta name="keywords" content="算法,树,二叉树,满二叉树,完全二叉树,二叉搜索树,红黑树,堆,堆排序">
<meta property="og:type" content="article">
<meta property="og:title" content="算法中树的总结">
<meta property="og:url" content="http://yoursite.com/2020/04/08/树/index.html">
<meta property="og:site_name" content="renhexin&#39;s blog">
<meta property="og:description" content="基本概念高度这个概念，其实就是从下往上度量，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是 0。 深度这个概念在生活中是从地面往下度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 0。 层数跟楼层类似，起点是 1，也就是说根节点的位于第 1 层。   满二叉树 叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/001.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/50/b4/50f89510ad1f7570791dd12f4e9adeb4.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/002.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/004.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/005.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/006.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/007.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/008.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/009.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/010.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/011.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/012.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/013.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/014.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/015.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/016.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/017.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/018.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/019.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/020.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/022.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/023.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/024.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/025、.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/树/026.png">
<meta property="og:updated_time" content="2020-04-12T14:51:56.315Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法中树的总结">
<meta name="twitter:description" content="基本概念高度这个概念，其实就是从下往上度量，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是 0。 深度这个概念在生活中是从地面往下度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 0。 层数跟楼层类似，起点是 1，也就是说根节点的位于第 1 层。   满二叉树 叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，">
<meta name="twitter:image" content="http://yoursite.com/2020/04/08/树/001.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/04/08/树/">





  <title>算法中树的总结 | renhexin's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">renhexin's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/08/树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RenHexin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renhexin's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">算法中树的总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-08T21:59:20+08:00">
                2020-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><code>高度</code>这个概念，其实就是从下往上度量，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是 0。</p>
<p><code>深度</code>这个概念在生活中是从地面往下度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 0。</p>
<p><code>层数</code>跟楼层类似，起点是 1，也就是说根节点的位于第 1 层。</p>
<p><img src="/2020/04/08/树/001.png" alt="img"></p>
<p><img src="https://static001.geekbang.org/resource/image/50/b4/50f89510ad1f7570791dd12f4e9adeb4.jpg" alt="img"></p>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><blockquote>
<p>叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树叫满二叉树。</p>
</blockquote>
<p><img src="/2020/04/08/树/002.png" alt="image-20200408221622785"></p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><blockquote>
<p>叶子节点都在最下面两层，最后一层叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都达到最大，这种二叉树叫完全二叉树。</p>
</blockquote>
<p><img src="/2020/04/08/树/004.png" alt="image-20200408221914572"></p>
<a id="more"></a>
<h3 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h3><ul>
<li>链式存储</li>
</ul>
<p><img src="/2020/04/08/树/005.png" alt="img"></p>
<ul>
<li>基于数组的顺序存储</li>
</ul>
<p>如果X节点存储在下标为i的数组中，则其左子节点下标为2<em>i，右子节点为2</em>i+ 1。反过来，其父节点下标为i/2。完全二叉树用数组存储，只浪费了下标为0的一个空间。</p>
<p>所以，如果一棵树是完全二叉树，用数组存储是最省内存的一种方式。</p>
<p>堆排序中的堆就是一颗完全二叉树。</p>
<p><img src="/2020/04/08/树/006.png" alt="img"></p>
<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p><code>前序遍历</code>、<code>中序遍历</code>、<code>后续遍历</code></p>
<p><img src="/2020/04/08/树/007.png" alt="img"></p>
<h3 id="遍历时间复杂度"><a href="#遍历时间复杂度" class="headerlink" title="遍历时间复杂度"></a>遍历时间复杂度</h3><p>从上图可以看出，遍历过程每个节点最多访问了两次，所以遍历的时间复杂度和节点个数n成正比，为<code>O(n)</code>。</p>
<p>节点定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先序遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(node.data)</span><br><span class="line">    preOrder(node.left);</span><br><span class="line">    preOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>中续遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">    inOrder(node.left);</span><br><span class="line">    System.out.print(node.data);</span><br><span class="line">    inOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>后续遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(node.left);</span><br><span class="line">    postOrder(node.right);</span><br><span class="line">    System.out.print(node.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>二叉查找树又名二叉搜索树，是二叉树中最常用的一种类型。顾名思义，二叉查找树是为了实现快速查找而生，除此之外，还支持快速插入、删除一个数据。这依赖于二叉查找树特殊的结构，树种任意一个节点，其左子树中每个节点的值都小于该节点的值，其右子树节点的值都大于该节点的值。</p>
<p><img src="/2020/04/08/树/008.png" alt="img"></p>
<h3 id="二叉查找树的查询"><a href="#二叉查找树的查询" class="headerlink" title="二叉查找树的查询"></a>二叉查找树的查询</h3><p>从根节点开始，和要查找的数据比较，相等则返回，小于根节点则从左子树中查找，大于则从右子树中查找，递归执行。</p>
<p><img src="/2020/04/08/树/009.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Node tree;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        Node p = tree;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.data == data)&#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.data &gt; data)&#123;</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node left;</span><br><span class="line">        <span class="keyword">private</span> Node right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉查找树的插入"><a href="#二叉查找树的插入" class="headerlink" title="二叉查找树的插入"></a>二叉查找树的插入</h3><p>这里插入到叶子节点上为例。从根节点开始遍历，依次比较数据和节点的大小，如果比插入数据大，且节点右子树为空，则插入到右子树，如果不为空，则递归右子树；相反，如果比节点值小，且节点左子树为空，则插入到左子树，如果不为空，则递归左子树。这里认为节点的值都不相等。</p>
<p><img src="/2020/04/08/树/010.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        Node p = tree;</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; p.data) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p.data) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉查找树的删除"><a href="#二叉查找树的删除" class="headerlink" title="二叉查找树的删除"></a>二叉查找树的删除</h3><p>根据要删除节点的子节点的不同，分为三种情况：</p>
<p>第一种：如果要删除节点没有子节点，只需将其父节点中指向该节点的指针指向null。</p>
<p>第二种：要删除节点只有一个子节点，只需将其父节点的指针指向其子节点即可。</p>
<p>第三种：要删除节点有两个子节点。我们需要找到其右子树中的最小节点，把它替换到要删除的节点，然后删除这个最小节点。</p>
<p><img src="/2020/04/08/树/011.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        Node p = tree;</span><br><span class="line">        Node pp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">            pp = p;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; p.data) &#123;</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有左右子树</span></span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node minP = p.right;</span><br><span class="line">            Node minPP = p;</span><br><span class="line">            <span class="keyword">while</span> (minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                minPP = minP;</span><br><span class="line">                minP = minPP.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到右子树的最小节点，替换</span></span><br><span class="line">            p.data = minP.data;</span><br><span class="line">            <span class="comment">//转换我删除minP的问题</span></span><br><span class="line">            p = minP;</span><br><span class="line">            pp = minPP;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//p的子节点</span></span><br><span class="line">        Node child = p.left == <span class="keyword">null</span> ? p.right : p.left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tree = child;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) &#123;</span><br><span class="line">            pp.left = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p) &#123;</span><br><span class="line">            pp.right = child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树查找最大最小值"><a href="#二叉搜索树查找最大最小值" class="headerlink" title="二叉搜索树查找最大最小值"></a>二叉搜索树查找最大最小值</h3><p>最小值在最左子树的左节点，最大值在最右子树的右节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node p = tree;</span><br><span class="line">        <span class="keyword">while</span>(p.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">findMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node p = tree;</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="支持重复数据的二叉搜索树"><a href="#支持重复数据的二叉搜索树" class="headerlink" title="支持重复数据的二叉搜索树"></a>支持重复数据的二叉搜索树</h3><p>针对两个节点有相同值的情况，有两种解决方式。</p>
<p>第一种：二叉搜索树中每个节点不仅存储一个数据，可以通过链表或者支持动态扩容的数组等结构，把有相同值的数据存储在同一个节点。</p>
<p>第二种：把相同值的节点插入这个节点的右子树，当做大于这个节点的值处理。则查找的时候，找到值相等的节点，继续在右子树中查找，直到叶节点为止；删除的时候，我们需要依次找到所有要删除的节点，然后按照前文的方法依次删除。</p>
<h3 id="二叉查找树的时间复杂度"><a href="#二叉查找树的时间复杂度" class="headerlink" title="二叉查找树的时间复杂度"></a>二叉查找树的时间复杂度</h3><p>下图是有相同节点的二叉查找树的三种不同形态。</p>
<p><img src="/2020/04/08/树/012.png" alt="img"></p>
<p>最差情况，退化成链表，查找的时间复杂度是O(n)。</p>
<p>最理性的情况是一个完全二叉树，从代码看，查找、删除、增加的时间复杂度都和树的高度成正比，也就是$O(height)$。</p>
<p><strong>如何求一颗包含了n个节点的完全二叉树的高度？</strong></p>
<p>对于完全二叉树，第一层有1个节点，第二层2个节点，第三层4个节点，第k层2^(k-1) 个节点。假设层数为h，则可以得到如下关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n &gt;= 1 + 2 + 4 + 8 + ... + 2^(k - 2) + 1</span><br><span class="line">n &lt;= 1 + 2 + 4 + 8 + ... + 2^(k - 2) + 2^(k - 1)</span><br></pre></td></tr></table></figure>
<p>得出k范围$[log_2(n+1), log_2n + 1]$</p>
<p>所以，完全二叉树的层数$k &lt; log_2n + 1$</p>
<p>二叉树高度$h &lt; log_2n$</p>
<h3 id="为什么有了散列表还要用二叉搜索树？"><a href="#为什么有了散列表还要用二叉搜索树？" class="headerlink" title="为什么有了散列表还要用二叉搜索树？"></a>为什么有了散列表还要用二叉搜索树？</h3><p>我们知道散列表的插入、删除、查找的时间复杂度可以做到常量级的O(1)。而二叉查找树在比较平衡的的情况下，插入、查找和删除的时间复杂度才是O(logn)。相比起来，好像并没有什么优势，为什么还要用二叉搜索树呢？</p>
<p>答案从排查问题、性能稳定性、查找效不确定性、实现复杂性、空间浪费几方面对比说明。</p>
<ol>
<li>散列表无序，如要输出有序的数据，需进行排序。二叉搜索树只需要中序遍历，就能在O(n)时间复杂度内，输出有序数据。</li>
<li>散列表扩容耗时很多，而当需要散列冲突时，性能不稳定。尽管二叉查找树性能不稳定，但工程中最常用的平衡二叉查找树并能非常稳定，时间复杂度稳定在O(logn)。</li>
<li>尽管散列报查找时间复杂度是O(1)，但因为hash冲突的存在，这个常量不一定比logn小，所以时间查找速度不一定比O(logn)快。加上hash函数耗时，也不一定比平衡二叉查找树效率高。</li>
<li>散列表的构造比二叉查找树要复杂，需考虑很多，比如散列函数设计、冲突的解决方法、扩容、缩容等。平衡二叉查找树只需要考虑平衡这一问题，而且问题的解决方案成熟、固定。</li>
<li>为了避免散列冲突，散列表的装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</li>
</ol>
<h2 id="平衡二叉查找树-amp-红黑树"><a href="#平衡二叉查找树-amp-红黑树" class="headerlink" title="平衡二叉查找树 &amp; 红黑树"></a>平衡二叉查找树 &amp; 红黑树</h2><p>前面说过，二叉查找树在频繁更新过程，可能退化为链表，导致操作效率退化到O(n)。</p>
<p>要解决这个复杂度退化的问题，我们需要设计一种平衡二叉查找树。</p>
<p>很多书籍里，但凡讲到平衡二叉树就会用红黑树举例子。不仅如此，有一定开发经验就会发现，在工程中，很多用平衡二叉查找树的地方都会用红黑树。</p>
<h3 id="什么是平衡二叉查找树？"><a href="#什么是平衡二叉查找树？" class="headerlink" title="什么是平衡二叉查找树？"></a>什么是平衡二叉查找树？</h3><p><code>平衡二叉树</code>定义：</p>
<p><code>平衡二叉树</code>中任意一个节点的左右子树的高度相差不能大于1。所以<code>完全二叉树</code>、<code>满二叉树</code>都是<code>平衡二叉树</code>，但<code>非完全二叉树</code>也可能是<code>平衡二叉树</code>。</p>
<p><img src="/2020/04/08/树/013.png" alt="img"></p>
<p><code>平衡二叉查找树</code>还满足二叉查找树的特点。</p>
<p><code>AVL树</code></p>
<p>最先被发明的平衡二叉查找树是<code>AVL树</code>，它严格负责平衡二叉树的定义，及任意节点子树高度相差不超过1，是一种高度平衡的二叉查找树。</p>
<p>很多平衡二叉树并没有严格符合平衡二叉树的定义:</p>
<blockquote>
<p>任意节点子树高度相差不超过1。</p>
</blockquote>
<p>比如红黑树，其根节点到各个叶节点的最长路径，有可能比最短路径大一倍。</p>
<p><strong>对于平衡，每必要死扣定义，它其实就是为了让整颗树看起比较对称，比较平衡，不要出现左右子树相差很高的情况，这样整棵树的高度相对更低一点，相应的查找、删除、添加操作的效率也会更高一些。</strong></p>
<h3 id="什么是红黑树？"><a href="#什么是红黑树？" class="headerlink" title="什么是红黑树？"></a>什么是红黑树？</h3><p>平衡二叉树有很多，如伸缩树（Splay Tree)、树堆（Treap)等，但提到平衡二叉树，听到的基本都是红黑树（Red-Black Tree），简称R-B Tree。</p>
<p>红黑树是一种不严格的平衡二叉树。</p>
<p>红黑树定义：</p>
<p>红黑树中的节点一类标记为红色，一类标记为黑色，除此之外，还需满足：</p>
<blockquote>
<ol>
<li>根节点是黑色的</li>
<li>叶节点都是黑色的空节点（NIL)，叶节点不存储数据。</li>
<li>任意相邻的节点不能同时为红色，也就是红节点被黑节点隔开。</li>
<li>每个节点到达其可达子节点的所有路径，都包含相同数目的黑色节点。</li>
</ol>
</blockquote>
<p>其中，<strong>第2点主要为了简化红黑树的代码实现设置的。</strong></p>
<h3 id="为什么工程中平衡二叉查找树多用红黑树这种结构？"><a href="#为什么工程中平衡二叉查找树多用红黑树这种结构？" class="headerlink" title="为什么工程中平衡二叉查找树多用红黑树这种结构？"></a>为什么工程中平衡二叉查找树多用红黑树这种结构？</h3><p>Treap、Splay Tree绝大多数情况下效率都很高，但是也无法避免极端情况下时间复杂度退化，尽管概率不大，但是对于单词操作敏感的场景，并不适用。</p>
<p>AVL树是一种高度平衡的二叉树，所以查找效率很高，但是AVL为了维持这种平衡，就要付出代价，每次插入、删除操作都要进行调整，复杂且耗时。所以有频繁插入、删除的数据集合，使用AVL代价有点高。</p>
<p>红黑树只是做了近似平衡，并不是严格平衡，所以在维护成本上，要比AVL树低。且红黑树的查找、插入、删除操作性能都比较稳定。对于工程应用，对面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于性能稳定的平衡二叉树。</p>
<h3 id="简述红黑树"><a href="#简述红黑树" class="headerlink" title="简述红黑树"></a>简述红黑树</h3><p>红黑树是一种性能稳定的二叉查找树，所以，在工程中但凡用到动态插入、删除、查找数据的场景，都可以使用它。不过，其实现复杂，如果自己写代码实现，难度较高，这时候，其实我们更倾向于用调表来代替它。</p>
<h2 id="堆与堆排序"><a href="#堆与堆排序" class="headerlink" title="堆与堆排序"></a>堆与堆排序</h2><p>堆是一种原地的、时间复杂度是O(nlongn)的排序算法。</p>
<h3 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h3><ul>
<li>堆是一颗完全二叉树。</li>
<li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</li>
</ul>
<p>对于每个节点都大于等于子节点的堆叫“大顶堆”，反之叫“小顶堆”。</p>
<p><img src="/2020/04/08/树/014.png" alt="image-20200412203919498"></p>
<h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><p>因为堆是一颗完全二叉树，所以非常适合用数组存储。而且可以通过数组下标容易的找到子节点和父节点。</p>
<p>如下图所示，数组中下标为i的节点的左子节点的下标为i <em> 2，右子节点的下标为2 </em> i + 1，父节点下标为i / 2。</p>
<p><img src="/2020/04/08/树/015.png" alt="image-20200412204119192"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] a; <span class="comment">//数组，从下标为1开始存储</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">//堆可以存储的最大数据个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">//当前堆中已有元素数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        n = capacity;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h3><h4 id="1-插入一个元素"><a href="#1-插入一个元素" class="headerlink" title="1. 插入一个元素"></a>1. 插入一个元素</h4><p>插入一个为了满足堆的特点，需要进行堆化处理。堆化有两种，从上往下和行下往上。下面为从下往上的堆化方法。</p>
<p>元素插入数组末尾</p>
<p><img src="/2020/04/08/树/016.png" alt="img"></p>
<p>顺着节点所在路径，从下往上与父节点比较，根据大小关系交换，一直重复，直到满足堆特征。</p>
<p><img src="/2020/04/08/树/017.png" alt="img"></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        a[count] = data; <span class="comment">//元素放到末尾</span></span><br><span class="line">        <span class="keyword">int</span> i = count;</span><br><span class="line">        <span class="keyword">while</span> (i / <span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; a[i / <span class="number">2</span>] &lt; a[i]) &#123;<span class="comment">//从下往上堆化</span></span><br><span class="line">            swap(a, i / <span class="number">2</span>, i);</span><br><span class="line">            i = i / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a[index1];</span><br><span class="line">        a[index1] = a[index2];</span><br><span class="line">        a[index2] = tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-删除堆顶元素"><a href="#2-删除堆顶元素" class="headerlink" title="2. 删除堆顶元素"></a>2. 删除堆顶元素</h4><p>这里以大顶堆为例。因为任何节点的值大于子节点的值，所以，堆顶元素的值是堆中的最大值。删除堆顶元素后，需要从左右子节点中找到第二大的元素放到堆顶。相当于删除了第二大元素所在子树的顶，因此这就是一个迭代处理问题了。</p>
<p><img src="/2020/04/08/树/018.png" alt="img"></p>
<p>这种思路可能出现空洞，转化下思路即使<strong>从上往下堆化方法</strong>。</p>
<p>把堆中最后一个元素放到堆顶，从堆顶开始，与左右子节点对比大小，不符合父子节点关系的交换，重复这个过程，直到无需交换级满足关系即可。</p>
<p><img src="/2020/04/08/树/019.png" alt="img"></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//末尾元素放到堆顶</span></span><br><span class="line">  a[<span class="number">1</span>] = a[count];</span><br><span class="line">  --count;</span><br><span class="line">  <span class="comment">//从上往下堆化</span></span><br><span class="line">  heapify(a, count, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从顶向下堆话</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a     堆 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> count 堆中已有数据容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i     当前堆话的节点下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> count, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxPos = i;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i &lt; count &amp;&amp; a[<span class="number">2</span> * i] &gt; a[maxPos]) &#123;</span><br><span class="line">      maxPos = <span class="number">2</span> * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; count &amp;&amp; a[<span class="number">2</span> * i + <span class="number">1</span>] &gt; a[maxPos]) &#123;</span><br><span class="line">      maxPos = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//至此已找到节点与两个子节点，这三个节点的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) &#123; <span class="comment">//满足关系，堆化完成</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换，继续堆化</span></span><br><span class="line">    swap(a, i, maxPos); </span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>一个包含n个节点的完全二叉树，树的高度不超过<br>$$<br>log_2n<br>$$<br>堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度与树的高度成正比，也就是O(logn)。插入与删除堆顶元素的主要逻辑是堆化，所以，堆中插入和删除堆顶元素的时间复杂度都是O(logn)。</p>
<h3 id="如何实现堆排序？"><a href="#如何实现堆排序？" class="headerlink" title="如何实现堆排序？"></a>如何实现堆排序？</h3><p>堆排序是时间复杂度为O(nlogn)，不稳定的原地排序算法。</p>
<p>堆排序的过程分为两步：</p>
<ol>
<li>建堆</li>
<li>排序</li>
</ol>
<p>回想前面的移除堆中最大元素（移除堆顶元素）过程。</p>
<p>包括两个过程：1、删除堆顶元素；2、对剩余元素堆化。</p>
<p>我们再对剩余堆中再进行删除最大元素操作，是不是相当于每次都从堆中取到了最大值？如果我们把删除操作改为把元素放在堆的最后面，这就是堆排序中的第二步：排序。</p>
<p>下面就剩下如何把一个乱序的数组建成一个堆。</p>
<h4 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h4><p>两种思路：</p>
<p>第一种：在堆中插入一个元素，就是下标为1的元素，然后调用前面的插入操作，将剩余数据插入堆中。</p>
<p>第二种：从后往前处理数组，从第一个非叶子节点开始从上往下堆化。</p>
<p><img src="/2020/04/08/树/020.png" alt="img"></p>
<p><img src="/2020/04/08/树/022.png" alt="img"></p>
<p>其实，对于一颗完全二叉树，下标n/2 + 1到n的节点都是叶子节点，下标1到n/2的节点都是非叶节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 堆排序</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> a 数组</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> n 数组元素个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//键堆，堆顶为最大元素</span></span><br><span class="line">  buildHeap(a, n);</span><br><span class="line">  <span class="keyword">int</span> k = n;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//堆顶和最后元素交换</span></span><br><span class="line">    swap(a, <span class="number">1</span>, k);</span><br><span class="line">    --k;</span><br><span class="line">    <span class="comment">//去除最后元素后进行堆化，堆顶为剩余元素最大值。</span></span><br><span class="line">    heapify(a, k, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 建堆</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> a 堆的数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> n 元素数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">  	heapify(a, n, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从顶向下堆话</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a     堆 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> count 堆中已有数据容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i     当前堆话的节点下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> count, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxPos = i;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i &lt; count &amp;&amp; a[<span class="number">2</span> * i] &gt; a[maxPos]) &#123;</span><br><span class="line">      maxPos = <span class="number">2</span> * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; count &amp;&amp; a[<span class="number">2</span> * i + <span class="number">1</span>] &gt; a[maxPos]) &#123;</span><br><span class="line">      maxPos = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//至此已找到节点与两个子节点，这三个节点的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) &#123; <span class="comment">//满足关系，堆化完成</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换，继续堆化</span></span><br><span class="line">    swap(a, i, maxPos); </span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>堆排序算法的时间复杂度包括两部分：</p>
<p>1、建堆的时间复杂度</p>
<p>2、排序的时间复杂度</p>
<p><strong>建堆过程时间复杂度</strong></p>
<p>需要堆化的节点从倒数第二层开始，每个节点堆化过程，需要比较和交换节点的个数，和节点的高度k成正比。如下图：</p>
<p><img src="/2020/04/08/树/023.png" alt="img"></p>
<p>计算过程：</p>
<p><img src="/2020/04/08/树/024.png" alt="img"></p>
<p>错位相减</p>
<p><img src="/2020/04/08/树/025、.png" alt="img"></p>
<p><img src="/2020/04/08/树/026.png" alt="img"></p>
<p>其中树高度$h=log_2n$，带入得$S = 2n - log_2n - 2$，转化为大O表示为$S = O(n)$，所以建堆的时间复杂度为$O(n)$。</p>
<p><strong>排序过程时间复杂度</strong></p>
<p>排序过程需要迭代堆化，每次堆化的时间复杂度为$O(logn)$，n次迭代复杂度为$O(nlogn)$。</p>
<p><strong>堆排序的时间复杂度</strong></p>
<p>建堆时间复杂度为$S = O(n)$，排序时间复杂度为$O(nlogn)$，所以堆排序的时间复杂度为$O(nlogn)$。</p>
<p><strong>堆排序空间复杂度</strong></p>
<p>整个排序过程，只需要极个别临时空间，所以堆排序是原地排序算法。</p>
<p>堆排序是不稳定排序算法，因为存在将堆中最后一个元素与堆顶元素交换的操作，所以可能改变相同数据的原始相对顺序。</p>
<h3 id="为什么实际开发中，快速排序比堆排序性能好？"><a href="#为什么实际开发中，快速排序比堆排序性能好？" class="headerlink" title="为什么实际开发中，快速排序比堆排序性能好？"></a>为什么实际开发中，快速排序比堆排序性能好？</h3><ol>
<li>堆排序的数据访问方式没有快排友好。</li>
<li><p>对于相同的数据，在排序过程中，堆排序的数据交换次数要多于快速排序。</p>
<p>前面讲过，有序度和逆序度。对于基于比较的排序算法，排序过程分为比较和交换。快排的数据交换次数不会超过逆序度。</p>
</li>
</ol>
<p>但是对排序第一步建堆可能打乱数据原有相对先后顺序，导致原有数据有序度降低。</p>
<h3 id="堆排序的应用？"><a href="#堆排序的应用？" class="headerlink" title="堆排序的应用？"></a>堆排序的应用？</h3><ol>
<li>求解top N问题</li>
<li>流里面的中值</li>
<li>流里面的中位数</li>
<li>优先级队列</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法/" rel="tag"># 算法</a>
          
            <a href="/tags/树/" rel="tag"># 树</a>
          
            <a href="/tags/二叉树/" rel="tag"># 二叉树</a>
          
            <a href="/tags/满二叉树/" rel="tag"># 满二叉树</a>
          
            <a href="/tags/完全二叉树/" rel="tag"># 完全二叉树</a>
          
            <a href="/tags/二叉搜索树/" rel="tag"># 二叉搜索树</a>
          
            <a href="/tags/红黑树/" rel="tag"># 红黑树</a>
          
            <a href="/tags/堆/" rel="tag"># 堆</a>
          
            <a href="/tags/堆排序/" rel="tag"># 堆排序</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/09/分布式锁/" rel="next" title="搞定分布式锁">
                <i class="fa fa-chevron-left"></i> 搞定分布式锁
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/21/SOLID/" rel="prev" title="设计原则：SOLID">
                设计原则：SOLID <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RenHexin</p>
              <p class="site-description motion-element" itemprop="description">Never Settle</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本概念"><span class="nav-number">1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#满二叉树"><span class="nav-number">1.1.</span> <span class="nav-text">满二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完全二叉树"><span class="nav-number">1.2.</span> <span class="nav-text">完全二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的存储"><span class="nav-number">1.3.</span> <span class="nav-text">二叉树的存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树遍历"><span class="nav-number">1.4.</span> <span class="nav-text">二叉树遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#遍历时间复杂度"><span class="nav-number">1.5.</span> <span class="nav-text">遍历时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉查找树"><span class="nav-number">2.</span> <span class="nav-text">二叉查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉查找树的查询"><span class="nav-number">2.2.</span> <span class="nav-text">二叉查找树的查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉查找树的插入"><span class="nav-number">2.3.</span> <span class="nav-text">二叉查找树的插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉查找树的删除"><span class="nav-number">2.4.</span> <span class="nav-text">二叉查找树的删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉搜索树查找最大最小值"><span class="nav-number">2.5.</span> <span class="nav-text">二叉搜索树查找最大最小值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#支持重复数据的二叉搜索树"><span class="nav-number">2.6.</span> <span class="nav-text">支持重复数据的二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉查找树的时间复杂度"><span class="nav-number">2.7.</span> <span class="nav-text">二叉查找树的时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么有了散列表还要用二叉搜索树？"><span class="nav-number">2.8.</span> <span class="nav-text">为什么有了散列表还要用二叉搜索树？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#平衡二叉查找树-amp-红黑树"><span class="nav-number">3.</span> <span class="nav-text">平衡二叉查找树 &amp; 红黑树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是平衡二叉查找树？"><span class="nav-number">3.1.</span> <span class="nav-text">什么是平衡二叉查找树？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是红黑树？"><span class="nav-number">3.2.</span> <span class="nav-text">什么是红黑树？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么工程中平衡二叉查找树多用红黑树这种结构？"><span class="nav-number">3.3.</span> <span class="nav-text">为什么工程中平衡二叉查找树多用红黑树这种结构？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简述红黑树"><span class="nav-number">3.4.</span> <span class="nav-text">简述红黑树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆与堆排序"><span class="nav-number">4.</span> <span class="nav-text">堆与堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是堆？"><span class="nav-number">4.1.</span> <span class="nav-text">什么是堆？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆的定义"><span class="nav-number">4.2.</span> <span class="nav-text">堆的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆的基本操作"><span class="nav-number">4.3.</span> <span class="nav-text">堆的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-插入一个元素"><span class="nav-number">4.3.1.</span> <span class="nav-text">1. 插入一个元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-删除堆顶元素"><span class="nav-number">4.3.2.</span> <span class="nav-text">2. 删除堆顶元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度分析"><span class="nav-number">4.3.3.</span> <span class="nav-text">时间复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何实现堆排序？"><span class="nav-number">4.4.</span> <span class="nav-text">如何实现堆排序？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#建堆"><span class="nav-number">4.4.1.</span> <span class="nav-text">建堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂度分析"><span class="nav-number">4.4.2.</span> <span class="nav-text">复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么实际开发中，快速排序比堆排序性能好？"><span class="nav-number">4.5.</span> <span class="nav-text">为什么实际开发中，快速排序比堆排序性能好？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆排序的应用？"><span class="nav-number">4.6.</span> <span class="nav-text">堆排序的应用？</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RenHexin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
